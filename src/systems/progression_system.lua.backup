-- Progression System
-- Manages player progression, tiers, achievements, and currency generation

local ProgressionSystem = {}
ProgressionSystem.__index = ProgressionSystem

local json = require("dkjson")

-- Create new progression system
function ProgressionSystem.new(eventBus, resourceSystem)
    local self = setmetatable({}, ProgressionSystem)
    self.eventBus = eventBus
    self.resourceSystem = resourceSystem
    
    -- Progression state
    self.currentTier = "novice"
    self.achievements = {}
    self.statistics = {
        rooms_visited = {},
        buildings_unlocked = {},
        contracts_completed = 0,
        total_focus_time = 0,
        max_focus_streak = 0,
        current_focus_streak = 0
    }
    
    -- Currency data and progression config
    self.currencies = {}
    self.tiers = {}
    self.achievementDefinitions = {}
    self.generation = {}
    
    -- Load progression data
    self:loadProgressionData()
    
    -- Initialize currencies in resource system
    self:initializeCurrencies()
    
-- Progression System - Comprehensive player advancement and currency management
-- Handles multiple currencies, progression tiers, prestige system, and milestones

local json = require("dkjson")
local ProgressionSystem = {}
ProgressionSystem.__index = ProgressionSystem

-- Create new progression system
function ProgressionSystem.new(eventBus)
    local self = setmetatable({}, ProgressionSystem)
    self.eventBus = eventBus
    
    -- Load progression configuration from JSON
    self.config = self:loadProgressionConfig()
    
    -- Player progression state
    self.currencies = {}
    self.currentTier = "startup"
    self.prestigeLevel = 0
    self.prestigePoints = 0
    self.completedMilestones = {}
    self.dailyConversions = {}
    
    -- Initialize currencies from config
    self:initializeCurrencies()
    
    -- Progression tracking
    self.totalStats = {
        totalEarnings = 0,
        totalSpent = 0,
        contractsCompleted = 0,
        specialistsHired = 0,
        crisisMissionsCompleted = 0
    }
    
    -- Subscribe to events
    self:subscribeToEvents()
    
    return self
end

-- Load progression configuration from JSON file
function ProgressionSystem:loadProgressionConfig()
    local json = require("src.utils.json")
    local dataPath = "src/data/progression.json"
    local config = nil
    
    -- Try to load from file system
    if love and love.filesystem and love.filesystem.getInfo then
        if love.filesystem.getInfo(dataPath) then
            local content = love.filesystem.read(dataPath)
            local ok, data = pcall(function() return json.decode(content) end)
            if ok and type(data) == "table" then
                config = data
            end
        end
    else
        -- Fallback for non-LOVE environment
        local file = io.open(dataPath, "r")
        if file then
            local content = file:read("*all")
            file:close()
            local success, decoded = pcall(json.decode, content)
            if success and decoded then
                config = decoded
            end
        end
    end
    
    -- Load progression data from currencies.json as fallback
    local currencyDataPath = "src/data/currencies.json"
    local progressionData = nil
    
    if love and love.filesystem and love.filesystem.getInfo then
        if love.filesystem.getInfo(currencyDataPath) then
            local content = love.filesystem.read(currencyDataPath)
            local ok, data = pcall(function() return json.decode(content) end)
            if ok and type(data) == "table" then
                progressionData = data
            end
        end
    else
        -- Fallback for non-LOVE environment
        local f = io.open(currencyDataPath, "r")
        if f then
            local content = f:read("*a")
            f:close()
            local ok, data = pcall(function() return json.decode(content) end)
            if ok and type(data) == "table" then
                progressionData = data
            end
        end
    end
    
    if progressionData then
        self.currencies = progressionData.currencies or {}
        self.tiers = progressionData.progression.tiers or {}
        self.achievementDefinitions = progressionData.progression.achievements or {}
        self.generation = progressionData.generation or {}
        print("💰 Loaded progression data: " .. self:getCurrencyCount() .. " currencies, " .. self:getTierCount() .. " tiers")
    else
        print("⚠️  Failed to load progression data, using defaults")
        self:createDefaultProgression()
    end
    
    return config
end

-- Initialize currencies in the resource system
function ProgressionSystem:initializeCurrencies()
    for currencyId, currencyData in pairs(self.currencies) do
        local startingAmount = currencyData.startingAmount or 0
        
        -- Set initial currency amount
        self.resourceSystem:setResource(currencyId, startingAmount)
        
        print("💰 Initialized " .. currencyData.name .. ": " .. startingAmount)
    end
end

-- Subscribe to game events for progression tracking
function ProgressionSystem:subscribeToEvents()
    -- Location events
    self.eventBus:subscribe("location_changed", function(data)
        self:onLocationChanged(data)
    end)
    
    self.eventBus:subscribe("building_unlocked", function(data)
        self:onBuildingUnlocked(data)
    end)
    
    -- Contract events
    self.eventBus:subscribe("contract_completed", function(data)
        self:onContractCompleted(data)
    end)
    
    -- Player state events
    self.eventBus:subscribe("focus_changed", function(data)
        self:onFocusChanged(data)
    end)
    
    -- Achievement events
    self.eventBus:subscribe("achievement_unlocked", function(data)
        self:onAchievementUnlocked(data)
    end)
end

-- Handle location change events
function ProgressionSystem:onLocationChanged(data)
    local locationKey = data.newBuilding .. "/" .. data.newFloor .. "/" .. data.newRoom
    
    -- Track room visits
    if not self.statistics.rooms_visited[locationKey] then
        self.statistics.rooms_visited[locationKey] = 0
        -- Check for first move achievement
        if self:getTotalRoomsVisited() == 1 then
            self:unlockAchievement("first_move")
        end
    end
    
    self.statistics.rooms_visited[locationKey] = (self.statistics.rooms_visited[locationKey] or 0) + 1
    
    -- Check for location master achievement
    self:checkLocationMasterAchievement(data.newBuilding)
    
    -- Apply location bonuses to currency generation
    -- This would be called with actual location bonuses from the location system
    -- For now, just store them for reference
end

-- Handle building unlock events
function ProgressionSystem:onBuildingUnlocked(data)
    self.statistics.buildings_unlocked[data.building] = true
    
    -- Award building owner achievement for first building unlock
    if self:getTotalBuildingsUnlocked() == 1 then
        self:unlockAchievement("building_owner")
    end
    
    -- Check for tier progression
    self:checkTierProgression()
end

-- Handle contract completion events
function ProgressionSystem:onContractCompleted(data)
    self.statistics.contracts_completed = self.statistics.contracts_completed + 1
    
    -- Award experience and reputation
    local baseExp = data.experience or 50
    local baseRep = data.reputation or 5
    
    -- Apply location bonuses
    local locationBonuses = self:getCurrentLocationBonuses()
    local expBonus = locationBonuses.xp_multiplier or 1.0
    local repBonus = locationBonuses.reputation or 1.0
    
    local finalExp = math.floor(baseExp * expBonus)
    local finalRep = math.floor(baseRep * repBonus)
    
    self.resourceSystem:addResource("experience", finalExp)
    self.resourceSystem:addResource("reputation", finalRep)
    
    print("🎯 Contract completed! +" .. finalExp .. " XP, +" .. finalRep .. " reputation")
    
    -- Check for tier progression
    self:checkTierProgression()
end

-- Handle achievement unlock events (for chaining achievements)
function ProgressionSystem:onAchievementUnlocked(data)
    -- This method can be used for achievement dependencies or effects
    print("🏆 Achievement effect processed: " .. data.id)
end

-- Handle focus change events
function ProgressionSystem:onFocusChanged(data)
    local focus = data.focus or 0
    
    if focus >= 200 then -- Maximum focus
        self.statistics.current_focus_streak = self.statistics.current_focus_streak + data.deltaTime
        self.statistics.total_focus_time = self.statistics.total_focus_time + data.deltaTime
        
        -- Check for efficiency expert achievement (5 minutes = 300 seconds)
        if self.statistics.current_focus_streak >= 300 and not self.achievements.efficiency_expert then
            self:unlockAchievement("efficiency_expert")
        end
        
        -- Track maximum streak
        self.statistics.max_focus_streak = math.max(self.statistics.max_focus_streak, self.statistics.current_focus_streak)
    else
        self.statistics.current_focus_streak = 0
    end
end

-- Update currency generation and progression
function ProgressionSystem:update(dt)
    -- Generate passive income
    self:updatePassiveIncome(dt)
    
    -- Update energy regeneration
    self:updateEnergyRegeneration(dt)
    
    -- Update focus decay
    self:updateFocusDecay(dt)
    
    -- Check for tier progression periodically
    -- In LÖVE, we can use love.timer, otherwise skip periodic checks
    if love and love.timer and love.timer.getTime() % 5 < dt then
        self:checkTierProgression()
    end
end

-- Update passive income generation
function ProgressionSystem:updatePassiveIncome(dt)
    local generation = self.generation.passive_income
    if not generation then return end
    
    local baseRate = generation.base_rate or 10
    local locationMultiplier = self:getLocationIncomeMultiplier()
    local tierMultiplier = self:getTierIncomeMultiplier()
    
    local totalRate = baseRate * locationMultiplier * tierMultiplier
    local income = totalRate * dt
    
    self.resourceSystem:addResource("money", income)
end

-- Update energy regeneration
function ProgressionSystem:updateEnergyRegeneration(dt)
    local energyCurrency = self.currencies.energy
    if not energyCurrency or not energyCurrency.regeneration then return end
    
    local baseRate = energyCurrency.regeneration.baseRate or 10
    local locationMultiplier = self:getLocationEnergyMultiplier()
    
    local totalRate = baseRate * locationMultiplier
    local regen = totalRate * dt
    
    local currentEnergy = self.resourceSystem:getResource("energy")
    local maxEnergy = energyCurrency.maxAmount or 100
    local newEnergy = math.min(maxEnergy, currentEnergy + regen)
    
    self.resourceSystem:setResource("energy", newEnergy)
end

-- Update focus decay
function ProgressionSystem:updateFocusDecay(dt)
    local focusCurrency = self.currencies.focus
    if not focusCurrency or not focusCurrency.decay then return end
    
    local baseRate = focusCurrency.decay.baseRate or 5
    local locationReduction = self:getLocationFocusDecayReduction()
    
    local totalRate = baseRate * (1 - locationReduction)
    local decay = totalRate * dt
    
    local currentFocus = self.resourceSystem:getResource("focus")
    local newFocus = math.max(0, currentFocus - decay)
    
    self.resourceSystem:setResource("focus", newFocus)
    
    -- Emit focus change event for streak tracking
    self.eventBus:publish("focus_changed", {
        focus = newFocus,
        deltaTime = dt
    })
end

-- Check if player can progress to next tier
function ProgressionSystem:checkTierProgression()
    local nextTierId = self:getNextTierId()
    if not nextTierId then return end
    
    local nextTier = self.tiers[nextTierId]
    if not nextTier or not nextTier.requirements then return end
    
    -- Check all requirements
    for resource, required in pairs(nextTier.requirements) do
        local current = 0
        
        if resource == "completed_contracts" then
            current = self.statistics.contracts_completed
        else
            current = self.resourceSystem:getResource(resource) or 0
        end
        
        if current < required then
            return -- Requirements not met
        end
    end
    
    -- All requirements met - promote to next tier!
    self:promoteToTier(nextTierId)
end

-- Promote player to next tier
function ProgressionSystem:promoteToTier(tierId)
    local tier = self.tiers[tierId]
    if not tier then return end
    
    local oldTier = self.currentTier
    self.currentTier = tierId
    
    -- Award tier rewards
    if tier.rewards then
        for resource, amount in pairs(tier.rewards) do
            self.resourceSystem:addResource(resource, amount)
        end
    end
    
    -- Emit tier change event
    self.eventBus:publish("tier_promoted", {
        oldTier = oldTier,
        newTier = self.currentTier
    })
end

-- Load configuration from JSON file
function ProgressionSystem:loadConfig()
    local config = {}
    local success, data = pcall(function()
        local json = require("src.utils.json")
        local file = io.open("src/data/progression_config.json", "r")
        if file then
            local content = file:read("*all")
            file:close()
            return json.decode(content)
        end
        return nil
    end)
    
    if success and data then
        config = data
    end
    
    -- Return config or empty structure if loading failed
    return config or {
        currencies = {},
        progressionTiers = {},
        prestigeSystem = {enabled = false},
        milestones = {},
        currencyConversions = {}
    }
end

-- Initialize currencies from configuration
function ProgressionSystem:initializeCurrencies()
    for categoryName, category in pairs(self.config.currencies or {}) do
        for currencyId, currencyConfig in pairs(category) do
            self.currencies[currencyId] = {
                amount = currencyConfig.startingAmount or 0,
                totalEarned = 0,
                totalSpent = 0,
                config = currencyConfig
            }
        end
    end
end

-- Subscribe to relevant events
function ProgressionSystem:subscribeToEvents()
    -- Resource changes
    self.eventBus:subscribe("resource_earned", function(data)
        self:onResourceEarned(data.resource, data.amount)
    end)
    
    self.eventBus:subscribe("resource_spent", function(data)
        self:onResourceSpent(data.resource, data.amount)
    end)
    
    -- Contract completion
    self.eventBus:subscribe("contract_completed", function(data)
        self.totalStats.contractsCompleted = self.totalStats.contractsCompleted + 1
        self:checkMilestones()
        self:checkTierProgression()
    end)
    
    -- Specialist hired
    self.eventBus:subscribe("specialist_hired", function(data)
        self.totalStats.specialistsHired = self.totalStats.specialistsHired + 1
        self:checkMilestones()
    end)
    
    -- Crisis mission completed
    self.eventBus:subscribe("crisis_mission_completed", function(data)
        self.totalStats.crisisMissionsCompleted = self.totalStats.crisisMissionsCompleted + 1
        self:awardCurrency("missionTokens", data.tokens or 1)
        self:checkMilestones()
    end)
    
    -- Check progression tier access
    self.eventBus:subscribe("check_progression_tier", function(data)
        local hasAccess = false
        local requiredTier = self.config.progressionTiers[data.requiredTier]
        local currentTier = self.config.progressionTiers[self.currentTier]
        
        if requiredTier and currentTier then
            hasAccess = currentTier.level >= requiredTier.level
        end
        
        if data.callback then
            data.callback(hasAccess)
        end
    end)
    
    -- Get currency amount for achievements
    self.eventBus:subscribe("get_currency_amount", function(data)
        local amount = self:getCurrency(data.currency)
        if data.callback then
            data.callback(amount)
        end
    end)
    
    -- Award currency from achievements
    self.eventBus:subscribe("award_currency", function(data)
        self:awardCurrency(data.currency, data.amount)
    end)
end

-- Award currency to player
function ProgressionSystem:awardCurrency(currencyId, amount)
    if not self.currencies[currencyId] then
        print("Warning: Unknown currency " .. currencyId)
        return false
    end
    
    local currency = self.currencies[currencyId]
    local config = currency.config
    
    -- Check storage limits
    if config.maxStorage and config.maxStorage > 0 then
        local maxAmount = config.maxStorage - currency.amount
        amount = math.min(amount, maxAmount)
    end
    
    if amount > 0 then
        currency.amount = currency.amount + amount
        currency.totalEarned = currency.totalEarned + amount
        
        -- Emit event for UI updates
        self.eventBus:publish("currency_awarded", {
            currency = currencyId,
            amount = amount,
            total = currency.amount
        })
        
        return true
    end
    
    return false
end

-- Spend currency
function ProgressionSystem:spendCurrency(currencyId, amount)
    if not self.currencies[currencyId] then
        return false
    end
    
    local currency = self.currencies[currencyId]
    
    if currency.amount >= amount and currency.config.canSpend then
        currency.amount = currency.amount - amount
        currency.totalSpent = currency.totalSpent + amount
        
        -- Emit event for UI updates
        self.eventBus:publish("currency_spent", {
            currency = currencyId,
            amount = amount,
            remaining = currency.amount
        })
        
        return true
    end
    
    return false
end

-- Check if player can afford a cost
function ProgressionSystem:canAfford(costs)
    for currencyId, amount in pairs(costs) do
        if not self.currencies[currencyId] or self.currencies[currencyId].amount < amount then
            return false
        end
    end
    return true
end

-- Spend multiple currencies
function ProgressionSystem:spendMultiple(costs)
    if not self:canAfford(costs) then
        return false
    end
    
    for currencyId, amount in pairs(costs) do
        self:spendCurrency(currencyId, amount)
    end
    
    return true
end

-- Get currency amount
function ProgressionSystem:getCurrency(currencyId)
    return self.currencies[currencyId] and self.currencies[currencyId].amount or 0
end

-- Get all currencies for display
function ProgressionSystem:getAllCurrencies()
    local result = {}
    
    -- Sort currencies by display order
    local sortedCurrencies = {}
    for currencyId, data in pairs(self.currencies) do
        table.insert(sortedCurrencies, {id = currencyId, data = data})
    end
    
    table.sort(sortedCurrencies, function(a, b)
        local orderA = a.data.config.displayOrder or 999
        local orderB = b.data.config.displayOrder or 999
        return orderA < orderB
    end)
    
    for _, entry in ipairs(sortedCurrencies) do
        result[entry.id] = entry.data
    end
    
    return result
end

-- Handle resource earned events
function ProgressionSystem:onResourceEarned(resource, amount)
    if resource == "money" then
        self.totalStats.totalEarnings = self.totalStats.totalEarnings + amount
    end
    
    self:awardCurrency(resource, amount)
end

-- Handle resource spent events
function ProgressionSystem:onResourceSpent(resource, amount)
    if resource == "money" then
        self.totalStats.totalSpent = self.totalStats.totalSpent + amount
    end
end

-- Check milestone completion
function ProgressionSystem:checkMilestones()
    for milestoneId, milestone in pairs(self.config.milestones or {}) do
        if not self.completedMilestones[milestoneId] then
            if self:isMilestoneComplete(milestone) then
                self:completeMilestone(milestoneId, milestone)
            end
        end
    end
end

-- Check if milestone requirements are met
function ProgressionSystem:isMilestoneComplete(milestone)
    for requirement, value in pairs(milestone.requirements) do
        local currentValue = 0
        
        if requirement == "totalEarnings" then
            currentValue = self.totalStats.totalEarnings
        elseif requirement == "contractsCompleted" then
            currentValue = self.totalStats.contractsCompleted
        elseif requirement == "specialistsHired" then
            currentValue = self.totalStats.specialistsHired
        elseif self.currencies[requirement] then
            currentValue = self.currencies[requirement].amount
        end
        
        if currentValue < value then
            return false
        end
    end
    
    return true
end

-- Complete a milestone
function ProgressionSystem:completeMilestone(milestoneId, milestone)
    self.completedMilestones[milestoneId] = true
    
    -- Award rewards
    if milestone.rewards then
        for rewardType, amount in pairs(milestone.rewards) do
            self:awardCurrency(rewardType, amount)
        end
    end
    
    -- Emit event for notifications
    self.eventBus:publish("milestone_completed", {
        id = milestoneId,
        milestone = milestone
    })
    
    print("🏆 Milestone completed: " .. milestone.name)
end

-- Check tier progression
function ProgressionSystem:checkTierProgression()
    for tierId, tier in pairs(self.config.progressionTiers or {}) do
        if tier.level > self:getCurrentTierLevel() and self:canAdvanceToTier(tier) then
            self:advanceToTier(tierId, tier)
            break
        end
    end
end

-- Get current tier level
function ProgressionSystem:getCurrentTierLevel()
    local currentTierData = self.config.progressionTiers[self.currentTier]
    return currentTierData and currentTierData.level or 1
end

-- Check if player can advance to tier
function ProgressionSystem:canAdvanceToTier(tier)
    for requirement, value in pairs(tier.requirements) do
        local currentValue = 0
        
        if requirement == "contracts" then
            currentValue = self.totalStats.contractsCompleted
        elseif requirement == "specialists" then
            currentValue = self.totalStats.specialistsHired
        elseif self.currencies[requirement] then
            currentValue = self.currencies[requirement].amount
        end
        
        if currentValue < value then
            return false
        end
    end
    
    return true
end

-- Advance to new tier
function ProgressionSystem:advanceToTier(tierId, tier)
    self.currentTier = tierId
    
    -- Emit tier advancement event
    self.eventBus:publish("tier_advanced", {
        newTier = tierId,
        tierData = tier
    })
    
    print("🎉 Promoted to " .. tier.name .. "!")
end

-- Unlock achievement
function ProgressionSystem:unlockAchievement(achievementId)
    if self.achievements[achievementId] then
        return -- Already unlocked
    end
    
    local achievement = self.achievementDefinitions[achievementId]
    if not achievement then return end
    
    self.achievements[achievementId] = {
        unlocked_at = (love and love.timer and love.timer.getTime()) or os.time(),
        id = achievementId
    }
    
    -- Award achievement rewards
    if achievement.rewards then
        for resource, amount in pairs(achievement.rewards) do
            self.resourceSystem:addResource(resource, amount)
        end
    end
    
    -- Emit achievement event
    self.eventBus:publish("achievement_unlocked", {
        id = achievementId,
        achievement = achievement
    })
    
    print("🏆 Achievement unlocked: " .. achievement.name)
end

-- Get current location bonuses from location system
function ProgressionSystem:getCurrentLocationBonuses()
    -- This would be provided by the location system
    -- For now, return empty table
    return {}
end

-- Helper methods for multipliers
function ProgressionSystem:getLocationIncomeMultiplier()
    local generation = self.generation.passive_income
    if not generation or not generation.location_multipliers then return 1.0 end
    
    -- This would use current location from location system
    return 1.0
end

function ProgressionSystem:getTierIncomeMultiplier()
    local generation = self.generation.passive_income
    if not generation or not generation.tier_multipliers then return 1.0 end
    
    return generation.tier_multipliers[self.currentTier] or 1.0
end

function ProgressionSystem:getLocationEnergyMultiplier()
    local energyCurrency = self.currencies.energy
    if not energyCurrency or not energyCurrency.regeneration or not energyCurrency.regeneration.locationMultipliers then 
        return 1.0 
    end
    
    -- This would use current room from location system
    return 1.0
end

function ProgressionSystem:getLocationFocusDecayReduction()
    local focusCurrency = self.currencies.focus
    if not focusCurrency or not focusCurrency.decay or not focusCurrency.decay.locationReduction then 
        return 0.0 
    end
    
    -- This would use current room from location system
    return 0.0
end

-- Achievement checking helpers
function ProgressionSystem:checkLocationMasterAchievement(buildingId)
    -- This would check if player has visited all rooms in the building
    -- Implementation would require location system integration
end

-- Utility methods
function ProgressionSystem:getCurrencyCount()
    local count = 0
    for _ in pairs(self.currencies) do count = count + 1 end
    return count
end

function ProgressionSystem:getTierCount()
    local count = 0
    for _ in pairs(self.tiers) do count = count + 1 end
    return count
end

function ProgressionSystem:getTotalRoomsVisited()
    local count = 0
    for _ in pairs(self.statistics.rooms_visited) do count = count + 1 end
    return count
end

function ProgressionSystem:getTotalBuildingsUnlocked()
    local count = 0
    for _ in pairs(self.statistics.buildings_unlocked) do count = count + 1 end
    return count
end

function ProgressionSystem:getNextTierId()
    local tierOrder = {"novice", "professional", "expert", "authority"}
    for i, tierId in ipairs(tierOrder) do
        if tierId == self.currentTier and i < #tierOrder then
            return tierOrder[i + 1]
        end
    end
    return nil
end

-- Get current tier information
function ProgressionSystem:getCurrentTier()
    return self.tiers[self.currentTier]
end

-- Get achievement progress
function ProgressionSystem:getAchievements()
    return self.achievements
end

-- Get statistics
function ProgressionSystem:getStatistics()
    return self.statistics
end

-- Get save state
function ProgressionSystem:getState()
    return {
        currentTier = self.currentTier,
        achievements = self.achievements,
        statistics = self.statistics
    }
end

-- Load state
function ProgressionSystem:setState(state)
    if state.currentTier then self.currentTier = state.currentTier end
    if state.achievements then self.achievements = state.achievements end
    if state.statistics then self.statistics = state.statistics end
end

-- Create default progression if JSON fails to load
function ProgressionSystem:createDefaultProgression()
    self.currencies = {
        money = { name = "Money", startingAmount = 1000 },
        reputation = { name = "Reputation", startingAmount = 10 },
        experience = { name = "Experience", startingAmount = 0 }
    }
    self.tiers = {
        novice = { name = "Novice Consultant", requirements = {} }
    }
    print("🚀 Advanced to " .. tier.name .. "!")
end

-- Convert currencies
function ProgressionSystem:convertCurrency(conversionId)
    local conversion = self.config.currencyConversions[conversionId]
    if not conversion or not conversion.enabled then
        return false
    end
    
    -- Check daily limits
    local today = os.date("%Y-%m-%d")
    if not self.dailyConversions[today] then
        self.dailyConversions[today] = {}
    end
    
    local dailyUsed = self.dailyConversions[today][conversionId] or 0
    if conversion.maxPerDay and dailyUsed >= conversion.maxPerDay then
        return false
    end
    
    -- Perform conversion (simplified - would need proper parsing for complex conversions)
    -- This is a basic implementation for XP to Skill Points
    if conversionId == "xpToSkillPoints" then
        if self:spendCurrency("xp", conversion.ratio) then
            self:awardCurrency("skillPoints", 1)
            self.dailyConversions[today][conversionId] = dailyUsed + 1
            return true
        end
    end
    
    return false
end

-- Perform prestige (company rebirth)
function ProgressionSystem:performPrestige()
    local prestigeConfig = self.config.prestigeSystem
    if not prestigeConfig.enabled then
        return false
    end
    
    -- Check requirements
    if not self:canPrestige() then
        return false
    end
    
    -- Calculate prestige points earned
    local earnedPoints = self:calculatePrestigePoints()
    
    -- Reset specified resources
    for _, resource in ipairs(prestigeConfig.resetResources) do
        if self.currencies[resource] then
            local config = self.currencies[resource].config
            self.currencies[resource].amount = config.startingAmount or 0
        end
    end
    
    -- Award prestige points
    self.prestigeLevel = self.prestigeLevel + 1
    self.prestigePoints = self.prestigePoints + earnedPoints
    self:awardCurrency("prestigePoints", earnedPoints)
    
    -- Reset progression tier
    self.currentTier = "startup"
    
    -- Reset stats
    self.totalStats.contractsCompleted = 0
    self.totalStats.specialistsHired = 0
    
    -- Emit prestige event
    self.eventBus:publish("prestige_performed", {
        level = self.prestigeLevel,
        pointsEarned = earnedPoints,
        totalPoints = self.prestigePoints
    })
    
    print("🌟 Prestige complete! Level: " .. self.prestigeLevel .. ", Points earned: " .. earnedPoints)
    return true
end

-- Check if prestige is available
function ProgressionSystem:canPrestige()
    local prestigeConfig = self.config.prestigeSystem
    if not prestigeConfig.enabled then
        return false
    end
    
    local requirements = prestigeConfig.unlockRequirements
    
    -- Check tier requirement
    if requirements.progressionTier then
        local requiredTier = self.config.progressionTiers[requirements.progressionTier]
        if not requiredTier or self:getCurrentTierLevel() < requiredTier.level then
            return false
        end
    end
    
    -- Check currency requirements
    for currency, amount in pairs(requirements) do
        if currency ~= "progressionTier" and self:getCurrency(currency) < amount then
            return false
        end
    end
    
    return true
end

-- Calculate prestige points to be earned
function ProgressionSystem:calculatePrestigePoints()
    local formula = self.config.prestigeSystem.prestigeFormula
    local base = formula.base or 1
    
    local moneyPoints = math.floor(self:getCurrency("money") / (formula.moneyDivisor or 50000))
    local reputationPoints = math.floor(self:getCurrency("reputation") / (formula.reputationDivisor or 100))
    
    return base + moneyPoints + reputationPoints
end

-- Get prestige bonuses
function ProgressionSystem:getPrestigeBonuses()
    local bonuses = {}
    local prestigeBonuses = self.config.prestigeSystem.prestigeBonuses or {}
    
    for bonusType, bonusConfig in pairs(prestigeBonuses) do
        -- Simplified bonus calculation (would need proper formula parser)
        if bonusType == "moneyGeneration" then
            bonuses[bonusType] = 1 + (self.prestigePoints * 0.1)
        elseif bonusType == "xpGeneration" then
            bonuses[bonusType] = 1 + (self.prestigePoints * 0.05)
        elseif bonusType == "contractCapacity" then
            bonuses[bonusType] = math.floor(self.prestigePoints * 0.5)
        elseif bonusType == "startingMoney" then
            bonuses[bonusType] = 1000 + (self.prestigePoints * 500)
        end
    end
    
    return bonuses
end

-- Get current progression tier info
function ProgressionSystem:getCurrentTier()
    return self.config.progressionTiers[self.currentTier] or {}
end

-- Update system
function ProgressionSystem:update(dt)
    -- Check for milestone and tier progression periodically
    self:checkMilestones()
    self:checkTierProgression()
end

-- Get state for saving
function ProgressionSystem:getState()
    return {
        currencies = self.currencies,
        currentTier = self.currentTier,
        prestigeLevel = self.prestigeLevel,
        prestigePoints = self.prestigePoints,
        completedMilestones = self.completedMilestones,
        totalStats = self.totalStats,
        dailyConversions = self.dailyConversions
    }
end

-- Load state from save
function ProgressionSystem:loadState(state)
    if state.currencies then
        -- Merge saved currencies with config, keeping saved amounts
        for currencyId, savedData in pairs(state.currencies) do
            if self.currencies[currencyId] then
                self.currencies[currencyId].amount = savedData.amount or 0
                self.currencies[currencyId].totalEarned = savedData.totalEarned or 0
                self.currencies[currencyId].totalSpent = savedData.totalSpent or 0
            end
        end
    end
    
    self.currentTier = state.currentTier or "startup"
    self.prestigeLevel = state.prestigeLevel or 0
    self.prestigePoints = state.prestigePoints or 0
    self.completedMilestones = state.completedMilestones or {}
    self.totalStats = state.totalStats or {
        totalEarnings = 0,
        totalSpent = 0,
        contractsCompleted = 0,
        specialistsHired = 0,
        crisisMissionsCompleted = 0
    }
    self.dailyConversions = state.dailyConversions or {}
end

return ProgressionSystem